/********************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ********************************************************************************
 */


#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

//#define MCU_as_Master
#define MCU_as_Slave

#include "stm32f103x6.h"
#include "stm32f103x6_gpio_driver.h"
#include "stm32f103x6_USART_driver.h"
#include "stm32f103x6_SPI_driver.h"





void clk_init(){
	//Enable clk for GPIOA
	RCC_GPIOA_CLK_EN();
	//Enable clk for GPIOB
	RCC_GPIOB_CLK_EN();
	//Enable clk for AFIO
	RCC_AFIO_CLK_EN();

}

unsigned short channel;

void SPI_IRQ_CallBack(SPI_IRQSrc_t irq_Src){
#ifdef	MCU_as_Slave
	if(irq_Src.RXNE){
		MCAL_SPI_Tx_Rx(SPI1,&channel,SPI_disable);
		MCAL_USART_SendData(USART1,&channel,enable);
	}
#endif
}

void USART_IRQ_CallBack(void){
#ifdef	MCU_as_Master
	MCAL_USART_ReceiveData(USART1, &channel, disable);
	MCAL_USART_SendData(USART1, &channel, enable);
	//send to SPI
	MCAL_GPIO_WritePin(GPIOA, GPIO_Pin_4, 0);
	MCAL_SPI_Tx_Rx(SPI1, &channel, SPI_enable);
	MCAL_GPIO_WritePin(GPIOA, GPIO_Pin_4, 1);
#endif
}

int main(void)
{	// initialization
	clk_init();
	USART_Config_t  uart_Cfg;
	SPI_Config_t 	spi_Cfg;
	GPIO_PinConfig_t PinCfg;
	//*************UART Init ************************
	uart_Cfg.Baud_Rate = USART_BaudRate_115200;
	uart_Cfg.HwFlowCtl = UART_HwFlowCtl_NONE;
	uart_Cfg.IRQ_Enable = UART_IRQ_Enable_RXNEIE;
	uart_Cfg.P_IRQ_CallBack = USART_IRQ_CallBack;
	uart_Cfg.Parity =UART_Parity__NONE;
	uart_Cfg.Payload_length = USART_Payload_8Bits;
	uart_Cfg.StopBits = UART_StopBits_1;
	uart_Cfg.USART_MODE = USART_MODE_Tx_Rx;

	MCAL_USART_Init(USART1, &uart_Cfg);
	MCAL_USART_SetPins(USART1);

	//*************SPI Init *************************
	spi_Cfg.Clk_Phase = SPI_ClkPhase_2ndClk_Data_CaptureEdge;
	spi_Cfg.Clk_Polarity = SPI_ClkPolarity_High_idle;
	spi_Cfg.Data_Size = SPI_DataSize_8Bit;
	spi_Cfg.Frame_Format = SPI_Frame_MSB_First;
	spi_Cfg.Communication_Mode = SPI_Comm_direction_2lines;
	spi_Cfg.Baud_Prescaler = SPI_BaudPrescaler_8; //assume pclk2 = 8Mhz -> SCK = 1Mhz

#ifdef	MCU_as_Master	//configuring for master
	spi_Cfg.Device_Mode = SPI_Device_Master;
	//configure NSS on PA4 by gpio (SW mode)
	spi_Cfg.NSS = SPI_NSS_SW_SSI_Set;
	PinCfg.GPIO_PinNumber = GPIO_Pin_4;
	PinCfg.GPIO_MODE = GPIO_MODE_Out_PP;
	PinCfg.GPIO_Out_Speed = GPIO_Speed_10M;
	MCAL_GPIO_Init(GPIOA, &PinCfg);
	//force slave select to high (idle value)
	MCAL_GPIO_WritePin(GPIOA, GPIO_Pin_4, 1);
	//no interrupt
	spi_Cfg.IRQ_En = SPI_IRQ_Enable_NONE;
	spi_Cfg.P_IRQ_CallBack = NULL;
#endif

#ifdef	MCU_as_Slave	//configuring for slave
	spi_Cfg.Device_Mode = SPI_Device_Slave;
	//configure NSS on PA4 as Slave (HW mode)
	spi_Cfg.NSS = SPI_NSS_HW_Slave;
	//enable RXNE interrupt flag
	spi_Cfg.IRQ_En = SPI_IRQ_Enable_RXNEIE;
	spi_Cfg.P_IRQ_CallBack = SPI_IRQ_CallBack;
#endif

	MCAL_SPI_Init(SPI1,&spi_Cfg);
	MCAL_SPI_SetPin(SPI1);


	/* Loop forever */
	while(1){

	}
}

